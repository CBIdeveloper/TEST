/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as v from "react";
import * as A from "react-dom";
import e from "prop-types";
import { slide as C } from "./animation.mjs";
import { classNames as P, uPopup as O, validatePackage as E, ZIndexContext as D, canUseDOM as x } from "@progress/kendo-react-common";
import { alignElement as M, positionElement as N, Collision as d, AlignPoint as p, domUtils as z } from "@progress/kendo-popup-common";
import { throttle as R, FRAME_DURATION as L } from "./util.mjs";
import { packageMetadata as I } from "./package-metadata.mjs";
const S = 100, U = 1;
function w(b, o) {
  if (b === o)
    return !0;
  if (!!b != !!o)
    return !1;
  const t = Object.getOwnPropertyNames(b), s = Object.getOwnPropertyNames(o);
  if (t.length !== s.length)
    return !1;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    if (b[i] !== o[i])
      return !1;
  }
  return !0;
}
const K = {
  left: -1e3,
  top: 0
}, y = class y extends v.Component {
  constructor(o) {
    super(o), this.context = 0, this.state = { current: "hidden", previous: "hidden", props: {} }, this._popup = null, this.show = (t) => {
      window == null || window.addEventListener("mousedown", this.handleMouseDown), this.setPosition(t), this.animate(t.firstChild, "enter", this.onOpened), this.setState({ current: "shown", previous: this.state.current });
    }, this.setPosition = (t) => {
      const { anchorAlign: s, popupAlign: n, collision: i, offset: a, anchor: l, margin: h, scale: c, positionMode: u } = this.props, { width: m, height: f } = t.style;
      t.style.width = t.offsetWidth + "px", t.style.height = t.offsetHeight + "px";
      const g = M({
        anchor: l,
        anchorAlign: s,
        element: t,
        elementAlign: n,
        offset: a,
        margin: h,
        positionMode: u,
        scale: c
      }), r = N({
        anchor: l,
        anchorAlign: s,
        element: t,
        elementAlign: n,
        collisions: i,
        currentLocation: g,
        margin: this.props.margin
      });
      if (t.style.top = r.offset.top + "px", t.style.left = r.offset.left + "px", t.style.width = m, t.style.height = f, this._collisions = {
        fit: r.fit,
        fitted: r.fitted,
        flip: r.flip,
        flipped: r.flipped
      }, this.props.onPosition) {
        const T = {
          target: this,
          flipped: r.flipped,
          fitted: r.fitted
        };
        this.props.onPosition.call(void 0, T);
      }
    }, this.onOpened = () => {
      const t = this._popup;
      if (t) {
        if (this.props.show) {
          const { unstyled: s } = this.props, n = s && s.uPopup;
          t.classList.add(
            ...P(O.animationContainerShown({ c: n })).split(" ").filter((i) => i)
          );
        }
        this.attachRepositionHandlers(t), this.props.onOpen && this.props.onOpen.call(void 0, { target: this });
      }
    }, this.animate = (t, s, n) => {
      if (!this.props.popupAlign)
        return;
      let i;
      const { horizontal: a, vertical: l } = this.props.popupAlign;
      a === "left" && l === "center" ? i = "right" : a === "right" && l === "center" ? i = "left" : l === "top" ? i = "down" : i = "up";
      const h = {
        down: "up",
        up: "down",
        left: "right",
        right: "left"
      };
      this._collisions && this._collisions.flipped && (i = h[i]);
      const { unstyled: c } = this.props, u = c && c.uPopup;
      C(t, i, this.animationDuration[s], s, n, u);
    }, this.handleMouseDown = (t) => {
      var i, a;
      const s = ((i = t == null ? void 0 : t.target) == null ? void 0 : i.closest(".k-animation-container")) === null, n = ((a = this.props.anchor) == null ? void 0 : a.contains(t == null ? void 0 : t.target)) || !1;
      if (s) {
        if (this.props.onMouseDownOutside) {
          const l = {
            target: this,
            event: t,
            state: this.state,
            isAnchorClicked: n
          };
          this.props.onMouseDownOutside.call(void 0, l);
        }
        window == null || window.removeEventListener("mousedown", this.handleMouseDown);
      }
    }, this.onClosing = (t) => {
      if (!this.props.show) {
        const { unstyled: s } = this.props, n = s && s.uPopup;
        t.classList.remove(
          ...P(O.animationContainerShown({ c: n })).split(" ").filter((i) => i)
        );
      }
      this.detachRepositionHandlers();
    }, this.onClosed = () => {
      this.state.current === "hiding" && this.state.previous === "shown" && this.setState({ current: "hidden", previous: this.state.current }), this.props.onClose && this.props.onClose.call(void 0, { target: this });
    }, this.getCurrentZIndex = () => this.context ? this.context + U : S, E(I), this.reposition = R(this.reposition.bind(this), L);
  }
  /**
   * Represents the Popup DOM element.
   */
  get element() {
    return this._popup;
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(o, t) {
    const {
      show: s,
      anchor: n,
      anchorAlign: i,
      appendTo: a,
      collision: l,
      popupAlign: h,
      className: c,
      popupClass: u,
      style: m,
      offset: f,
      contentKey: g
    } = o, r = {
      ...t,
      props: {
        show: s,
        anchor: n,
        anchorAlign: i,
        appendTo: a,
        collision: l,
        popupAlign: h,
        className: c,
        popupClass: u,
        style: m,
        offset: f,
        contentKey: g
      }
    };
    return o.show ? t.current === "hidden" || t.current === "hiding" ? { ...r, current: "showing", previous: t.current } : t.current === "showing" ? { ...r, current: "shown", previous: t.current } : t.current === "shown" && (!w(f, t.props.offset) || !w(i, t.props.anchorAlign) || !w(a, t.props.appendTo) || !w(l, t.props.collision) || !w(h, t.props.popupAlign) || !w(m, t.props.style) || n !== t.props.anchor || u !== t.props.popupClass || c !== t.props.className) ? { ...r, current: "reposition", previous: t.current } : r : t.current === "hiding" || t.current === "hidden" ? { ...r, current: "hidden", previous: t.current } : { ...r, current: "hiding", previous: t.current };
  }
  /**
   *
   * @hidden
   */
  componentDidUpdate(o) {
    this.state.current === "showing" && this._popup ? this.show(this._popup) : this.state.current === "hiding" && this._popup ? (this.onClosing(this._popup), this.animate(this._popup.firstChild, "exit", this.onClosed)) : this.state.current === "reposition" && this.state.previous === "shown" ? setTimeout(() => {
      this.setState({ current: "shown", previous: this.state.current });
    }, 0) : this.state.current === "shown" && o.contentKey !== this.props.contentKey && this._popup && this.setPosition(this._popup);
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.state.current === "showing" && this._popup && this.show(this._popup);
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.detachRepositionHandlers();
  }
  /**
   * @hidden
   */
  render() {
    const { children: o, className: t, popupClass: s, unstyled: n, show: i, id: a, positionMode: l } = this.props, h = n && n.uPopup, c = this.props.appendTo ? this.props.appendTo : x ? this.props.anchor && this.props.anchor.ownerDocument ? this.props.anchor.ownerDocument.body : document.body : void 0;
    this.state.current === "reposition" && this.state.previous === "shown" && this._popup && this.setPosition(this._popup);
    const u = Object.assign(
      {},
      { position: l, top: 0, left: -1e4 },
      this.props.style || {}
    ), m = this.state.current === "hiding";
    if ((i || m) && c) {
      const f = this.getCurrentZIndex(), g = /* @__PURE__ */ v.createElement(D.Provider, { value: f }, /* @__PURE__ */ v.createElement(
        "div",
        {
          onKeyDown: this.props.onKeyDown,
          className: P(O.animationContainer({ c: h }), t),
          id: a,
          ref: (r) => this._popup = r,
          style: {
            zIndex: f,
            ...u
          }
        },
        /* @__PURE__ */ v.createElement(
          "div",
          {
            className: P(O.animationChild({ c: h })),
            style: { transitionDelay: "0ms" }
          },
          /* @__PURE__ */ v.createElement(
            "div",
            {
              role: this.props.role,
              className: P(O.popup({ c: h }), s)
            },
            o
          )
        )
      ));
      return this.props.appendTo !== null ? A.createPortal(g, c) : g;
    }
    return null;
  }
  get animationDuration() {
    const o = this.props.animate;
    let t = 0, s = 0;
    return o && (o === !0 ? t = s = 300 : (t = o.openDuration || 0, s = o.closeDuration || 0)), { enter: t, exit: s };
  }
  attachRepositionHandlers(o) {
    this.detachRepositionHandlers(), this._scrollableParents = z.scrollableParents(this.props.anchor || o), this._scrollableParents && this._scrollableParents.map((t) => t.addEventListener("scroll", this.reposition)), window.addEventListener("resize", this.reposition);
  }
  detachRepositionHandlers() {
    this._scrollableParents && (this._scrollableParents.map((o) => o.removeEventListener("scroll", this.reposition)), this._scrollableParents = void 0), window.removeEventListener("resize", this.reposition);
  }
  reposition() {
    this.setState({ current: "reposition", previous: this.state.current });
  }
};
y.propTypes = {
  anchor: function(o) {
    const t = o.anchor;
    return t && typeof t.nodeType != "number" ? new Error("Invalid prop `anchor` supplied to `Kendo React Popup`. Validation failed.") : null;
  },
  appendTo: function(o) {
    const t = o.appendTo;
    return t && typeof t.nodeType != "number" ? new Error("Invalid prop `appendTo` supplied to `Kendo React Popup`. Validation failed.") : null;
  },
  className: e.oneOfType([e.string, e.arrayOf(e.string), e.object]),
  id: e.string,
  popupClass: e.oneOfType([e.string, e.arrayOf(e.string), e.object]),
  collision: e.shape({
    horizontal: e.oneOf([d.fit, d.flip, d.none]),
    vertical: e.oneOf([d.fit, d.flip, d.none])
  }),
  anchorAlign: e.shape({
    horizontal: e.oneOf([p.left, p.center, p.right]),
    vertical: e.oneOf([p.top, p.center, p.bottom])
  }),
  popupAlign: e.shape({
    horizontal: e.oneOf([p.left, p.center, p.right]),
    vertical: e.oneOf([p.top, p.center, p.bottom])
  }),
  offset: e.shape({
    left: e.number,
    top: e.number
  }),
  children: e.oneOfType([e.element, e.node]),
  show: e.bool,
  animate: e.oneOfType([
    e.bool,
    e.shape({
      openDuration: e.number,
      closeDuration: e.number
    })
  ]),
  margin: e.shape({
    horizontal: e.number,
    vertical: e.number
  }),
  positionMode: e.oneOf(["fixed", "absolute"]),
  scale: e.number,
  style: e.object,
  onClose: e.func,
  onPosition: e.func,
  onOpen: e.func,
  onKeyPress: e.func,
  onMouseDownOutside: e.func
}, y.defaultProps = {
  collision: {
    horizontal: d.fit,
    vertical: d.flip
  },
  anchorAlign: {
    horizontal: p.left,
    vertical: p.bottom
  },
  popupAlign: {
    horizontal: p.left,
    vertical: p.top
  },
  offset: K,
  animate: !0,
  show: !1,
  margin: {
    horizontal: 0,
    vertical: 0
  },
  positionMode: "absolute"
}, y.contextType = D, y.displayName = "PopupComponent";
let _ = y;
export {
  _ as PopupWithoutContext
};
