/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as u from "react";
import C from "prop-types";
import { classNames as x, uDropDownList as D, Keys as I, validatePackage as ee, svgIconPropType as te, canUseDOM as B, getTabIndex as se, IconWrap as ie, uDropDownsActionSheet as K, createPropsContext as ae, withIdHOC as oe, withPropsContext as ne, withUnstyledHOC as re } from "@progress/kendo-react-common";
import { FloatingLabel as le } from "@progress/kendo-react-labels";
import { caretAltDownIcon as de, xIcon as pe } from "@progress/kendo-svg-icons";
import he from "../common/ListContainer.mjs";
import ce from "../common/ListFilter.mjs";
import W from "../common/GroupStickyHeader.mjs";
import ue from "../common/ListDefaultItem.mjs";
import me from "../common/List.mjs";
import R from "../common/DropDownBase.mjs";
import { getFilteredData as E, areSame as k, getItemValue as T, sameCharsOnly as fe, shuffleData as ge, matchText as q, isPresent as U, itemIndexStartsWith as ve } from "../common/utils.mjs";
import { packageMetadata as be } from "../package-metadata.mjs";
import { Button as G } from "@progress/kendo-react-buttons";
import { provideLocalizationService as Ie } from "@progress/kendo-react-intl";
import { dropDownListArrowBtnAriaLabel as Y, messages as ye } from "../messages/index.mjs";
import { MOBILE_SMALL_DEVISE as $, MOBILE_MEDIUM_DEVISE as j } from "../common/constants.mjs";
import { ActionSheet as we, ActionSheetHeader as Se, ActionSheetContent as xe } from "@progress/kendo-react-layout";
const Ce = "Please select a value from the list!", N = class N extends u.Component {
  constructor(s) {
    super(s), this.state = {}, this._element = null, this.base = new R(this), this.searchState = { word: "", last: "" }, this._select = null, this._skipFocusEvent = !1, this._filterInput = null, this._navigated = !1, this._lastKeypressIsFilter = !1, this.itemHeight = 0, this.focus = () => {
      this.base.wrapper && this.base.wrapper.focus({ preventScroll: !0 });
    }, this.handleItemSelect = (e, t) => {
      const { virtual: a, dataItemKey: h, defaultItem: n } = this.props, l = E(this.props), b = a ? a.skip : 0, d = e === -1 && n !== void 0 ? n : l[e - b], i = !k(d, this.value, h);
      this.triggerOnChange(d, t), i && this.base.triggerPageChangeCornerItems(d, t);
    }, this.componentRef = (e) => {
      this._element = e, this.base.wrapper = e;
    }, this.dummySelect = (e) => /* @__PURE__ */ u.createElement(
      "select",
      {
        name: this.props.name,
        ref: (t) => {
          this._select = t;
        },
        tabIndex: -1,
        "aria-hidden": !0,
        title: this.props.label,
        style: { opacity: 0, width: 1, border: 0, zIndex: -1, position: "absolute", left: "50%" }
      },
      /* @__PURE__ */ u.createElement("option", { value: this.props.valueMap ? this.props.valueMap.call(void 0, e) : e })
    ), this.renderListContainer = () => {
      const { header: e, footer: t, dir: a, size: h, groupField: n, groupStickyHeaderItemRender: l, list: b, unstyled: d } = this.props, i = E(this.props), c = this.base, o = c.getPopupSettings(), f = this.props.opened !== void 0 ? this.props.opened : this.state.opened, g = o.width !== void 0 ? o.width : c.popupWidth, p = d && d.uDropDownList, r = {
        dir: a !== void 0 ? a : c.dirCalculated,
        width: g,
        popupSettings: {
          ...o,
          popupClass: x(
            o.popupClass,
            D.listContainer({
              c: p
            })
          ),
          anchor: o.anchor || this.element,
          show: f,
          onOpen: this.onPopupOpened,
          onClose: this.onPopupClosed,
          onMouseDownOutside: this.onPopupMouseDown
        },
        itemsCount: [i.length]
      };
      let { group: w } = this.state;
      return w === void 0 && n !== void 0 && (w = T(i[0], n)), /* @__PURE__ */ u.createElement(he, { ...r }, this.renderListFilter(), e && /* @__PURE__ */ u.createElement("div", { className: x(D.listHeader({ c: p })) }, e), /* @__PURE__ */ u.createElement(
        "div",
        {
          className: x(
            D.list({
              c: p,
              size: h,
              virtual: this.base.vs.enabled
            })
          )
        },
        this.renderDefaultItem(),
        !b && w && i.length !== 0 && /* @__PURE__ */ u.createElement(W, { group: w, groupMode: "modern", render: l }),
        this.renderList()
      ), t && /* @__PURE__ */ u.createElement("div", { className: x(D.listFooter({ c: p })) }, t));
    }, this.renderList = () => {
      const {
        textField: e,
        dataItemKey: t,
        virtual: a = { skip: 0, total: void 0 },
        groupHeaderItemRender: h,
        listNoDataRender: n,
        itemRender: l,
        unstyled: b
      } = this.props, d = E(this.props), i = b && b.uDropDownList, c = this.base.vs, o = a.skip, f = this.props.opened !== void 0 ? this.props.opened : this.state.opened, g = this.base.getPopupSettings(), p = `translateY(${c.translate}px)`;
      return /* @__PURE__ */ u.createElement(
        me,
        {
          id: this._listboxId,
          show: f,
          data: d.slice(),
          focusedIndex: this.getFocusedIndex(),
          value: this.value,
          textField: e,
          valueField: t,
          optionsGuid: this._guid,
          groupField: this.props.groupField,
          groupMode: "modern",
          listRef: (r) => c.list = this.base.list = r,
          wrapperStyle: { maxHeight: g.height },
          wrapperCssClass: x(D.listContent({ c: i })),
          listStyle: c.enabled ? { transform: p } : void 0,
          key: "listkey",
          skip: o,
          onClick: this.handleItemClick,
          itemRender: l,
          groupHeaderItemRender: h,
          noDataRender: n,
          onScroll: this.onScroll,
          wrapperRef: c.scrollerRef,
          scroller: this.base.renderScrollElement(),
          ariaSetSize: a.total
        }
      );
    }, this.onScroll = (e) => {
      const { vs: t, list: a } = this.base;
      t.scrollHandler(e);
      const { groupField: h } = this.props;
      let n = E(this.props);
      if (!(!h || !n.length) && h) {
        const l = this.itemHeight = this.itemHeight || (t.enabled ? t.itemHeight : a ? a.children[0].offsetHeight : 0), d = e.target.scrollTop - t.skip * l;
        n = this.base.getGroupedDataModernMode(n, h);
        let i = n[0][h];
        for (let c = 1; c < n.length && !(l * c > d); c++)
          n[c] && n[c][h] && (i = n[c][h]);
        i !== this.state.group && this.setState({
          group: i
        });
      }
    }, this.renderListFilter = () => {
      const e = this.props.filter !== void 0 ? this.props.filter : this.state.text;
      return this.props.filterable && /* @__PURE__ */ u.createElement(
        ce,
        {
          value: e,
          ref: (t) => this._filterInput = t && t.element,
          onChange: this.handleListFilterChange,
          onKeyDown: this.handleKeyDown,
          size: this.props.size,
          rounded: this.props.rounded,
          fillMode: this.props.fillMode,
          renderListFilterWrapper: !0
        }
      );
    }, this.renderDefaultItem = () => {
      const { textField: e, defaultItem: t, dataItemKey: a } = this.props;
      return t !== void 0 && /* @__PURE__ */ u.createElement(
        ue,
        {
          defaultItem: t,
          textField: e,
          selected: k(this.value, t, a),
          key: "defaultitemkey",
          onClick: this.handleDefaultItemClick
        }
      );
    }, this.search = (e) => {
      clearTimeout(this._typingTimeout), this.props.filterable || (this._typingTimeout = window.setTimeout(() => this.searchState.word = "", this.props.delay), this.selectNext(e));
    }, this.selectNext = (e) => {
      const { dataItemKey: t } = this.props, a = E(this.props);
      let h = a.map((F, M) => ({ item: F, itemIndex: M }));
      const n = this.searchState.word, l = this.searchState.last, b = fe(n, l);
      let d = h.length, i = Math.max(
        0,
        a.findIndex((F) => k(F, this.value, t))
      ), c;
      this.props.defaultItem && (c = { item: this.props.defaultItem, itemIndex: -1 }, d += 1, i += 1), i += b ? 1 : 0, h = ge(h, i, c);
      let o, f, g, p = 0;
      const { textField: r, ignoreCase: w } = this.props;
      for (; p < d; p++)
        if (o = T(h[p].item, r), f = b && q(o, l, w), g = q(o, n, w), f || g) {
          p = h[p].itemIndex;
          break;
        }
      if (p !== d) {
        const F = this.base.initState();
        F.syntheticEvent = e, this.handleItemSelect(p, F), this.applyState(F), this._valueDuringOnChange = void 0;
      }
    }, this.handleKeyDown = (e) => {
      e && e.target instanceof Element && e.target.nodeName === "INPUT" && e.stopPropagation && e.stopPropagation();
      const {
        filterable: t,
        disabled: a,
        defaultItem: h,
        leftRightKeysNavigation: n = !0,
        virtual: l = { skip: 0, total: 0, pageSize: 0 },
        dataItemKey: b,
        groupField: d = "",
        textField: i,
        skipDisabledItems: c = !0
      } = this.props, o = E(this.props), f = this.value, g = o.findIndex((y) => k(y, f, b)), p = this.props.opened !== void 0 ? this.props.opened : this.state.opened, r = e.keyCode, w = r === I.home || r === I.end, F = r === I.up || r === I.down, M = !p && (e.altKey && r === I.down || r === I.enter || r === I.space), _ = p && (e.altKey && r === I.up || r === I.esc), z = n && (r === I.left || r === I.right), P = F || z && !t || w, S = this.base.initState();
      if (S.syntheticEvent = e, !a) {
        if (w && this.base.vs.enabled)
          r === I.home ? l.skip !== 0 ? (this.base.triggerOnPageChange(S, 0, l.pageSize), this._navigated = !0) : this.triggerOnChange(o[0], S) : l.skip < l.total - l.pageSize ? (this.base.triggerOnPageChange(S, l.total - l.pageSize, l.pageSize), this._navigated = !0) : this.triggerOnChange(o[o.length - 1], S);
        else if (p && r === I.pageUp)
          e.preventDefault(), this.base.scrollPopupByPageSize(-1);
        else if (p && r === I.pageDown)
          e.preventDefault(), this.base.scrollPopupByPageSize(1);
        else if (p && r === I.enter) {
          const y = this.getFocusedIndex();
          this.haveFocusedItemAndDataNotEmpty(o, y) ? (this.triggerOnChange(null, S), this.applyState(S)) : this.handleItemSelect(y, S), this.base.togglePopup(S), e.preventDefault();
        } else if (M || _)
          _ && this.resetValueIfDisabledItem(), this.base.togglePopup(S), e.preventDefault();
        else if (P) {
          if (this._lastKeypressIsFilter = !1, d !== "" && i)
            if (!c && p)
              this.onNavigate(S, r);
            else {
              let y;
              if (r === I.down || r === I.right) {
                const v = o.slice(g + 1).find((m) => !m.disabled && m[i]);
                y = v && o.findIndex((m) => m[i] === v[i]);
              } else if (r === I.up || r === I.left) {
                let v;
                if (g === 0 && h)
                  y = -1;
                else if (g === -1)
                  v = o, y = o.findIndex((m) => !m.disabled && m[i]);
                else {
                  v = o.slice(0, g);
                  let m = v.pop();
                  for (; m && m.disabled; )
                    m = v.pop();
                  y = m && o.findIndex((L) => L[i] === m[i]);
                }
              }
              if (y !== void 0) {
                const v = y - g;
                this.onNavigate(S, r, v);
              } else
                y === void 0 && o.findIndex((v) => v[i] === f[i]) === o.length - 1 && this.onNavigate(S, r);
            }
          else if (!c && p || w)
            this.onNavigate(S, r);
          else if (i) {
            let y;
            if (r === I.down || r === I.right) {
              const v = o.slice(g + 1).find((m) => !m.disabled && m[i]);
              y = v && o.findIndex((m) => m[i] === v[i]);
            } else if (r === I.up || r === I.left) {
              let v;
              if (g === 0 && h)
                y = -1;
              else if (g === -1)
                v = o, y = o.find((m) => !m.disabled && m[i]);
              else {
                v = o.slice(0, g);
                let m = v.pop();
                for (; m && m.disabled; )
                  m = v.pop();
                y = m && o.findIndex((L) => L[i] === m[i]);
              }
            }
            if (y !== void 0) {
              const v = y - g;
              this.onNavigate(S, r, v);
            } else
              y === void 0 && o.findIndex((v) => v[i] === f[i]) === o.length - 1 && this.onNavigate(S, r);
          } else
            this.onNavigate(S, r);
          e.preventDefault();
        }
        this.applyState(S);
      }
    }, this.handleItemClick = (e, t) => {
      this.base.handleItemClick(e, t), this._valueDuringOnChange = void 0;
    }, this.handleFocus = (e) => {
      this._skipFocusEvent || this.base.handleFocus(e);
    }, this.handleBlur = (e) => {
      if (this._skipFocusEvent || !this.state.focused)
        return;
      const t = this.props.opened !== void 0 ? this.props.opened : this.state.opened, { adaptive: a } = this.props, { windowWidth: h = 0 } = this.state, n = h <= j && a, l = this.base.initState();
      l.syntheticEvent = e, l.data.focused = !1, l.events.push({ type: "onBlur" }), t && this.resetValueIfDisabledItem(), t && !n && this.base.togglePopup(l), this.applyState(l);
    }, this.handleDefaultItemClick = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e, this.base.togglePopup(t), this.triggerOnChange(this.props.defaultItem, t), this.applyState(t);
    }, this.handleWrapperClick = (e) => {
      if (e.isPropagationStopped())
        return;
      const t = this.base.initState();
      t.syntheticEvent = e, this.state.focused || (t.data.focused = !0), this.resetValueIfDisabledItem(), this.base.togglePopup(t), this.applyState(t);
    }, this.handleKeyPress = (e) => {
      if (this.props.filterable || e.which === 0 || e.keyCode === I.enter)
        return;
      let t = String.fromCharCode(e.charCode || e.keyCode);
      this.props.ignoreCase && (t = t.toLowerCase()), t === " " && e.preventDefault(), this.searchState = {
        word: this.searchState.word + t,
        last: this.searchState.last + t
      }, this.search(e);
    }, this.handleListFilterChange = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e.syntheticEvent, this.props.filter === void 0 && (t.data.text = e.target.value), this.base.filterChanged(e.target.value, t), this._lastKeypressIsFilter = !0, this.applyState(t), this.setState({ group: void 0 });
    }, this.onPopupOpened = () => {
      this._filterInput && this.focusElement(this._filterInput), this.props.adaptive && setTimeout(() => {
        this._filterInput && this.focusElement(this._filterInput);
      }, 300);
    }, this.onPopupClosed = () => {
      this.state.focused && window.setTimeout(() => {
        this.state.focused && this.base.wrapper && this.focusElement(this.base.wrapper);
      });
    }, this.onPopupMouseDown = (e) => {
      var t;
      (t = this.props.popupSettings) != null && t.onMouseDownOutside && this.props.popupSettings.onMouseDownOutside.call(void 0, e);
    }, this.togglePopup = () => {
      const e = this.base.initState();
      e.data.opened = this.state.opened, this.base.togglePopup(e), this.applyState(e);
    }, this.setValidity = () => {
      this._select && this._select.setCustomValidity && this._select.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || Ce
      );
    }, ee(be);
  }
  get _inputId() {
    return this.props.id + "-accessibility-id";
  }
  get _listboxId() {
    return this.props.id + "-listbox-id";
  }
  get _guid() {
    return this.props.id + "-guid";
  }
  get document() {
    if (B)
      return this.element && this.element.ownerDocument || document;
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  /**
   * The value of the DropDownList.
   */
  get value() {
    let s;
    return this._valueDuringOnChange !== void 0 ? s = this._valueDuringOnChange : this.props.value !== void 0 ? s = this.props.value : this.state.value !== void 0 ? s = this.state.value : this.props.defaultValue !== void 0 && (s = this.props.defaultValue), !U(s) && this.props.defaultItem !== void 0 && (s = this.props.defaultItem), s;
  }
  /**
   * The index of the selected item.
   */
  get index() {
    const { dataItemKey: s } = this.props, e = E(this.props), t = this.value;
    return e.findIndex((a) => k(a, t, s));
  }
  /**
   * Gets the `name` property of the DropDownList.
   */
  get name() {
    return this.props.name;
  }
  /**
   * Represents the validity state into which the DropDownList is set.
   */
  get validity() {
    const s = this.props.validationMessage !== void 0, e = !this.required || this.value !== null && this.value !== "" && this.value !== void 0, t = this.props.valid !== void 0 ? this.props.valid : e;
    return {
      customError: s,
      valid: t,
      valueMissing: this.value === null
    };
  }
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : N.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : N.defaultProps.required;
  }
  /**
   * @hidden
   */
  componentDidUpdate(s, e) {
    var o;
    const { dataItemKey: t, virtual: a, groupField: h = "", textField: n } = this.props, l = E(this.props), b = s.virtual ? s.virtual.total : 0, d = this.props.opened !== void 0 ? this.props.opened : this.state.opened, i = s.opened !== void 0 ? s.opened : e.opened, c = !i && d;
    if (this.base.didUpdate(), this.base.getPopupSettings().animate || c && this.onPopupOpened(), a && a.total !== b)
      this.base.vs.calcScrollElementHeight(), this.base.vs.reset();
    else {
      const f = this.value, g = s.value !== void 0 ? s.value : e.value;
      let p = l.findIndex((w) => k(w, f, t));
      h !== "" && f && n && (p = (o = this.base.getGroupedDataModernMode(l, h)) == null ? void 0 : o.map((w) => w[n]).indexOf(f[n]));
      const r = !k(g, f, t);
      c && a ? this.base.scrollToVirtualItem(a, p) : c && !a ? (this.onPopupOpened(), l && l.length !== 0 && this.base.resetGroupStickyHeader(l[0][h], this), this.base.scrollToItem(p)) : d && i && f && r && !this._navigated ? this.base.scrollToItem(p, this.base.vs.enabled) : d && i && this._navigated && (this._navigated && a && a.skip === 0 ? this.base.vs.reset() : this._navigated && a && a.skip === a.total - a.pageSize && this.base.vs.scrollToEnd());
    }
    this._navigated = !1, this.setValidity();
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var s;
    this.observerResize = B && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), this.base.didMount(), this.setValidity(), (s = this.document) != null && s.body && this.observerResize && this.observerResize.observe(this.document.body);
  }
  /** @hidden */
  componentWillUnmount() {
    var s;
    (s = this.document) != null && s.body && this.observerResize && this.observerResize.disconnect();
  }
  /**
   * @hidden
   */
  render() {
    const s = Ie(this).toLanguageString(
      Y,
      ye[Y]
    ), { style: e, className: t, label: a, dir: h, virtual: n, size: l, rounded: b, fillMode: d, adaptive: i, unstyled: c } = this.props, { windowWidth: o = 0 } = this.state, f = this.props.opened !== void 0 ? this.props.opened : this.state.opened, g = this.value, p = T(g, this.props.textField), r = !this.validityStyles || this.validity.valid, w = this.base, F = w.vs, M = o <= j && i, _ = c && c.uDropDownList;
    F.enabled = n !== void 0, n !== void 0 && (w.vs.skip = n.skip, w.vs.total = n.total, w.vs.pageSize = n.pageSize);
    const { dataItemKey: z, disabled: P, tabIndex: S, loading: y, iconClassName: v, svgIcon: m, valueRender: L } = this.props, J = E(this.props), { focused: Q } = this.state, X = J.findIndex((O) => k(O, g, z)), H = /* @__PURE__ */ u.createElement("span", { id: this._inputId, className: x(D.inputInner({ c: _ })) }, p && /* @__PURE__ */ u.createElement("span", { className: x(D.inputText({ c: _ })) }, p)), Z = L !== void 0 ? L.call(void 0, H, g) : H, V = /* @__PURE__ */ u.createElement(u.Fragment, null, /* @__PURE__ */ u.createElement(
      "span",
      {
        ref: this.componentRef,
        className: x(
          D.wrapper({
            c: _,
            size: l,
            rounded: b,
            fillMode: d,
            focused: Q,
            disabled: P,
            invalid: !r,
            loading: y,
            required: this.required
          }),
          t
        ),
        style: a ? { ...e, width: void 0 } : e,
        dir: h,
        onMouseDown: f ? (O) => {
          O.target.nodeName !== "INPUT" && (this.focusElement(this.base.wrapper), O.preventDefault());
        } : void 0,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        tabIndex: se(S, P),
        accessKey: this.props.accessKey,
        onKeyDown: this.handleKeyDown,
        onKeyPress: this.handleKeyPress,
        onClick: P ? void 0 : this.handleWrapperClick,
        role: "combobox",
        "aria-required": this.required,
        "aria-disabled": P || void 0,
        "aria-haspopup": "listbox",
        "aria-expanded": f || !1,
        "aria-owns": this._listboxId,
        "aria-activedescendant": f ? "option-" + this._guid + "-" + (X + (n ? n.skip : 0)) : void 0,
        "aria-label": this.props.ariaLabel || this.props.label,
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-describedby": this.props.ariaDescribedBy || this._inputId,
        "aria-controls": this._listboxId,
        id: this.props.id,
        title: this.props.title
      },
      Z,
      y && /* @__PURE__ */ u.createElement(ie, { className: x(D.loadingIcon({ c: _ })), name: "loading" }),
      /* @__PURE__ */ u.createElement(
        G,
        {
          tabIndex: -1,
          type: "button",
          "aria-label": s,
          size: l,
          fillMode: d,
          iconClass: v,
          className: x(D.inputButton({ c: _ })),
          rounded: null,
          themeColor: "base",
          icon: v ? void 0 : "caret-alt-down",
          svgIcon: m || de,
          onMouseDown: (O) => this.state.focused && O.preventDefault()
        }
      ),
      this.dummySelect(g),
      !M && this.renderListContainer()
    ), M && this.renderAdaptiveListContainer());
    return a ? /* @__PURE__ */ u.createElement(
      le,
      {
        label: a,
        editorValue: p,
        editorValid: r,
        editorDisabled: this.props.disabled,
        style: { width: e ? e.width : void 0 },
        children: V
      }
    ) : V;
  }
  /**
   * @hidden
   */
  onNavigate(s, e, t) {
    const { defaultItem: a, dataItemKey: h, virtual: n = { skip: 0, total: 0, pageSize: 0 } } = this.props, l = E(this.props), b = this.base.vs, d = this.value, i = l.findIndex((o) => k(o, d, h)), c = this.base.navigation.navigate({
      current: n.skip + i,
      max: (b.enabled ? n.total : l.length) - 1,
      min: a !== void 0 ? -1 : 0,
      keyCode: e,
      skipItems: t || void 0
    });
    c !== void 0 && this.handleItemSelect(c, s), this.applyState(s);
  }
  renderAdaptiveListContainer() {
    const { windowWidth: s = 0 } = this.state, { header: e, footer: t, size: a, adaptiveTitle: h, groupField: n, groupStickyHeaderItemRender: l, list: b, unstyled: d } = this.props, i = E(this.props), c = this.props.opened !== void 0 ? this.props.opened : this.state.opened, o = d && d.uDropDownList, f = d && d.uDropDownsActionSheet, g = {
      navigatable: !1,
      navigatableElements: [],
      expand: c,
      animation: !0,
      onClose: (r) => this.handleWrapperClick(r),
      animationStyles: s <= $ ? { top: 0, width: "100%", height: "100%" } : void 0,
      className: x(
        K.wrapper({
          c: f,
          isFullScreen: s <= $
        })
      )
    };
    let { group: p } = this.state;
    return p === void 0 && n !== void 0 && (p = T(i[0], n)), /* @__PURE__ */ u.createElement(we, { ...g }, /* @__PURE__ */ u.createElement(Se, { className: x(K.header({ c: f })) }, /* @__PURE__ */ u.createElement("div", { className: x(K.titleBar({ c: f })) }, /* @__PURE__ */ u.createElement("div", { className: x(K.title({ c: f })) }, /* @__PURE__ */ u.createElement("div", null, h)), /* @__PURE__ */ u.createElement("div", { className: x(K.actions({ c: f })) }, /* @__PURE__ */ u.createElement(
      G,
      {
        tabIndex: 0,
        "aria-label": "Cancel",
        "aria-disabled": "false",
        type: "button",
        fillMode: "flat",
        onClick: this.handleWrapperClick,
        icon: "x",
        svgIcon: pe
      }
    ))), /* @__PURE__ */ u.createElement("div", { className: x(K.titleBarGroup({ c: f })) }, this.renderListFilter())), /* @__PURE__ */ u.createElement(xe, { overflowHidden: !0 }, e && /* @__PURE__ */ u.createElement("div", { className: x(D.listHeader({ c: o })) }, e), /* @__PURE__ */ u.createElement(
      "div",
      {
        className: x(
          D.list({
            c: o,
            size: a,
            virtual: this.base.vs.enabled
          })
        )
      },
      this.renderDefaultItem(),
      !b && p && i.length !== 0 && /* @__PURE__ */ u.createElement(
        W,
        {
          group: p,
          groupMode: "modern",
          render: l
        }
      ),
      this.renderList()
    ), t && /* @__PURE__ */ u.createElement("div", { className: x(D.listFooter({ c: o })) }, t)));
  }
  getFocusedIndex() {
    const s = this.value, {
      textField: e,
      dataItemKey: t,
      virtual: a = { skip: 0 },
      focusedItemIndex: h = ve,
      filterable: n,
      skipDisabledItems: l = !0
    } = this.props, b = E(this.props), d = this.props.filter ? this.props.filter : this.state.text;
    return l && e && !d && !s ? b.findIndex((i) => !i.disabled && i[e]) : U(s) && d === void 0 || n && d === "" ? b.findIndex((i) => k(i, s, t)) : d ? this._lastKeypressIsFilter ? h(b, d, e) : b.findIndex((i) => k(i, s, t)) : a.skip === 0 ? 0 : -1;
  }
  focusElement(s) {
    this._skipFocusEvent = !0, s.focus(), window.setTimeout(() => this._skipFocusEvent = !1, 30);
  }
  triggerOnChange(s, e) {
    k(this.value, s, this.props.dataItemKey) || (this.props.value === void 0 && (e.data.value = s), this._valueDuringOnChange = s, e.events.push({ type: "onChange" }));
  }
  applyState(s) {
    this.base.applyState(s), this._valueDuringOnChange = void 0;
  }
  calculateMedia(s) {
    for (const e of s)
      this.setState({ windowWidth: e.target.clientWidth });
  }
  resetValueIfDisabledItem() {
    const s = E(this.props), e = this.base.initState(), t = this.getFocusedIndex();
    this.haveFocusedItemAndDataNotEmpty(s, t) && (this.triggerOnChange(null, e), this.applyState(e));
  }
  haveFocusedItemAndDataNotEmpty(s, e) {
    return e !== void 0 && e !== -1 && s && s.length > 0 && s[e].disabled;
  }
};
N.displayName = "DropDownList", N.propTypes = {
  delay: C.number,
  ignoreCase: C.bool,
  iconClassName: C.string,
  svgIcon: te,
  defaultItem: C.any,
  valueRender: C.func,
  valueMap: C.func,
  validationMessage: C.string,
  required: C.bool,
  id: C.string,
  ariaLabelledBy: C.string,
  ariaDescribedBy: C.string,
  ariaLabel: C.string,
  leftRightKeysNavigation: C.bool,
  title: C.string,
  groupField: C.string,
  list: C.any,
  skipDisabledItems: C.bool,
  renderListFilterWrapper: C.bool,
  ...R.propTypes
}, N.defaultProps = {
  delay: 500,
  tabIndex: 0,
  ignoreCase: !0,
  ...R.defaultProps,
  required: !1,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  groupMode: "modern"
};
let A = N;
const De = ae(), Ee = oe(
  ne(
    De,
    re(A)
  )
);
Ee.displayName = "KendoReactDropDownList";
export {
  Ee as DropDownList,
  De as DropDownListPropsContext,
  A as DropDownListWithoutContext
};
