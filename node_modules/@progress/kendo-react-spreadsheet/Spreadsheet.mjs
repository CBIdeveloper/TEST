/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as t from "react";
import l from "prop-types";
import { ToolbarSeparator as Z, Toolbar as $, ButtonGroup as ee, Button as te } from "@progress/kendo-react-buttons";
import { TabStrip as re, TabStripTab as oe } from "@progress/kendo-react-layout";
import { Dialog as ne, DialogActionsBar as ae } from "@progress/kendo-react-dialogs";
import { FormulaInput as H } from "./FormulaInput.mjs";
import { NameBox as le } from "./NameBox.mjs";
import { SheetsBar as se } from "./SheetsBar.mjs";
import { SpreadsheetWidget as ce } from "@progress/kendo-spreadsheet-common";
import { defaultTabs as L } from "./tools/defaultTools.mjs";
import { validatePackage as ie, shouldShowValidationUI as ue, classNames as me, IconWrap as de, WatermarkOverlay as fe } from "@progress/kendo-react-common";
import { packageMetadata as T } from "./package-metadata.mjs";
import { formulaFxIcon as pe } from "@progress/kendo-svg-icons";
import { useLocalization as z, useInternationalization as ge } from "@progress/kendo-react-intl";
import { saveAs as ke } from "@progress/kendo-file-saver";
import { Workbook as be } from "@progress/kendo-ooxml";
import { keys as m, messages as g } from "./messages.mjs";
const B = ["bold", "italic", "underline", "fontFamily", "fontSize", "color", "background", "textAlign", "verticalAlign", "wrap", "gridLines"], O = {
  Bold: (r) => r.bold,
  Italic: (r) => r.italic,
  Underline: (r) => r.underline,
  FontFamily: (r) => r.fontFamily,
  FontSize: (r) => r.fontSize,
  IncreaseFontSize: (r) => r.fontSize,
  DecreaseFontSize: (r) => r.fontSize,
  TextColor: (r) => r.color,
  BackgroundColor: (r) => r.background,
  Alignment: (r) => ({ textAlign: r.textAlign, verticalAlign: r.verticalAlign }),
  AlignHorizontally: (r) => r.textAlign,
  AlignVertically: (r) => r.verticalAlign,
  TextWrap: (r) => r.wrap,
  GridLines: (r) => r.gridLines,
  AddColumnLeft: (r) => r.selectedHeaders,
  AddColumnRight: (r) => r.selectedHeaders,
  AddRowBelow: (r) => r.selectedHeaders,
  AddRowAbove: (r) => r.selectedHeaders,
  DeleteColumn: (r) => r.selectedHeaders,
  DeleteRow: (r) => r.selectedHeaders
}, J = ":not(.k-dropdownlist button):not(.k-combobox button):not(.k-upload-button):not(.k-colorpicker button):not(.k-split-button .k-split-button-arrow)", he = [
  "button" + J,
  ".k-button-group > button" + J,
  ".k-dropdownlist",
  ".k-combobox",
  ".k-colorpicker"
], W = t.forwardRef((r, K) => {
  ie(T);
  const P = ue(T), { toolbar: b = L } = r, d = [];
  typeof b == "boolean" ? d.push(...b ? L : []) : d.push(...b);
  const [c, v] = t.useState(null), [D, G] = t.useState(d.findIndex((e) => e.selected) || 0), [Se, M] = t.useState(!1), h = t.useRef(null), x = t.useRef(null), y = t.useRef(null), C = t.useRef(null), a = t.useRef(null), [S, U] = t.useState({}), k = t.useRef({});
  k.current = S;
  const s = t.useRef({});
  s.current = r;
  const E = z(), V = t.useCallback((e) => {
    s.current.onSelect && s.current.onSelect.call(void 0, e);
  }, []), j = t.useCallback((e) => {
    s.current.onChange && s.current.onChange.call(void 0, e);
  }, []), _ = t.useCallback((e) => {
    s.current.onChangeFormat && s.current.onChangeFormat.call(void 0, e);
  }, []), q = t.useCallback((e) => {
    s.current.onExcelImport && s.current.onExcelImport.call(void 0, e);
  }, []), Q = t.useCallback((e) => {
    s.current.onExcelExport && s.current.onExcelExport.call(void 0, e);
  }, []), w = t.useRef(null);
  t.useImperativeHandle(w, () => ({
    element: h.current,
    get instance() {
      return a.current;
    },
    props: r,
    get view() {
      return a.current.view;
    },
    get workbook() {
      return a.current.workbook;
    },
    executeCommand(e) {
      var o;
      (o = a.current) == null || o.executeCommand(e);
    },
    fromJSON(e) {
      var o;
      return (o = a.current) == null ? void 0 : o.fromJSON(e);
    },
    toJSON() {
      return a.current.toJSON();
    },
    saveJSON() {
      return a.current.saveJSON();
    },
    fromFile(e) {
      return a.current.fromFile(e);
    },
    saveAsExcel(e) {
      var o;
      (o = a.current) == null || o.saveAsExcel({
        ...a.current.options.excel,
        saveAs: ke,
        Workbook: be,
        ...e
      });
    },
    activeSheet(e) {
      var o;
      return (o = a.current) == null ? void 0 : o.activeSheet(e);
    },
    sheets() {
      return a.current.sheets();
    },
    refresh() {
      var e;
      return (e = a.current) == null ? void 0 : e.refresh();
    }
  }), [r]), t.useImperativeHandle(K, () => w.current);
  const X = t.useCallback(() => a.current && a.current.view.nameEditor, []), N = t.useCallback((e) => {
    const o = {};
    B.forEach((n) => {
      typeof e.range[n] == "function" ? o[n] = e.range[n]() : n === "gridLines" && (o[n] = e.range.sheet().showGridLines());
    }), o.selectedHeaders = e.range.sheet().selectedHeaders(), (B.some((n) => o[n] !== k.current[n]) || o.selectedHeaders.allCols !== k.current.selectedHeaders.allCols || o.selectedHeaders.allRows !== k.current.selectedHeaders.allRows) && U(o);
  }, []), Y = t.useCallback((e) => {
    const o = e.name, n = m[o];
    v({
      title: e.title === "Error" ? E.toLanguageString(m.error, g[m.error]) : e.title,
      message: n ? E.toLanguageString(n, g[n] || e.text) : e.text,
      close: e.close
    });
  }, []), R = t.useCallback(() => {
    v(null), c == null || c.close();
  }, [c]), f = ge(), A = z();
  t.useEffect(() => {
    var p;
    const e = {
      ...r.defaultProps,
      sheets: structuredClone((p = r.defaultProps) == null ? void 0 : p.sheets),
      messages: {
        workbook: {
          defaultSheetName: A.toLanguageString(m.defaultSheetName, g[m.defaultSheetName])
        }
      },
      intl: {
        localeInfo: () => f.localeInfo(),
        localeCurrency: () => f.localeCurrency(),
        parseDate: (i, u) => f.parseDate(i, u),
        toString: (i, u) => f.toString(i, u),
        format: (i, ...u) => f.format(i, ...u)
      },
      formulaBarInputRef: x,
      formulaCellInputRef: y,
      nameBoxRef: C
    }, o = new ce(h.current, e);
    a.current = o, o.bind("select", V), o.bind("change", j), o.bind("changeFormat", _), o.bind("excelImport", q), o.bind("excelExport", Q), o.view.bind("update", N), o.view.bind("message", Y);
    const n = o.activeSheet();
    return n && N({ range: n.range(n.activeCell()) }), M(!0), () => {
      o.destroy();
    };
  }, []);
  const I = t.useCallback((e, o) => {
    const n = /* @__PURE__ */ t.createElement(
      e,
      {
        spreadsheetRef: a,
        value: O[e.displayName] ? O[e.displayName](S) : void 0,
        key: o
      }
    );
    return n.type === Z ? /* @__PURE__ */ t.createElement(e, { key: o }) : n;
  }, [S]);
  let F = null;
  return d.length && (F = /* @__PURE__ */ t.createElement(
    re,
    {
      selected: D,
      animation: !1,
      className: "k-floatwrap k-spreadsheet-tabstrip",
      style: { minHeight: "auto" },
      onSelect: (e) => G(e.selected)
    },
    d.map((e) => {
      const o = e.textKey ? A.toLanguageString(e.textKey, g[e.textKey]) : e.text;
      return /* @__PURE__ */ t.createElement(oe, { key: e.textKey || e.text, title: o }, /* @__PURE__ */ t.createElement($, { buttons: he, className: "k-spreadsheet-toolbar" }, e.tools.map((n, p) => Array.isArray(n) ? /* @__PURE__ */ t.createElement(ee, { key: p }, n.map((i, u) => I(i, u))) : I(n, p))));
    })
  )), /* @__PURE__ */ t.createElement(
    "div",
    {
      ref: h,
      style: r.style,
      className: me("k-widget k-spreadsheet", r.className),
      role: "application"
    },
    F,
    /* @__PURE__ */ t.createElement("div", { className: "k-spreadsheet-action-bar" }, /* @__PURE__ */ t.createElement(le, { ref: C, nameEditor: X }), /* @__PURE__ */ t.createElement("div", { className: "k-spreadsheet-formula-bar" }, /* @__PURE__ */ t.createElement(de, { name: "formula-fx", icon: pe }), /* @__PURE__ */ t.createElement(H, { ref: x }))),
    /* @__PURE__ */ t.createElement("div", { className: "k-spreadsheet-view" }, /* @__PURE__ */ t.createElement("div", { className: "k-spreadsheet-fixed-container" }), /* @__PURE__ */ t.createElement("div", { className: "k-spreadsheet-scroller" }, /* @__PURE__ */ t.createElement("div", { className: "k-spreadsheet-view-size" })), /* @__PURE__ */ t.createElement("div", { tabIndex: 0, className: "k-spreadsheet-clipboard", contentEditable: "true" }), /* @__PURE__ */ t.createElement(H, { ref: y, className: "k-spreadsheet-cell-editor" })),
    /* @__PURE__ */ t.createElement(se, { spreadsheetRef: a }),
    c && /* @__PURE__ */ t.createElement(ne, { title: c.title, onClose: R }, /* @__PURE__ */ t.createElement("div", null, c.message), /* @__PURE__ */ t.createElement(ae, { layout: "start" }, /* @__PURE__ */ t.createElement(
      te,
      {
        themeColor: "primary",
        onClick: R,
        autoFocus: !0
      },
      E.toLanguageString(m.ok, g[m.ok])
    ))),
    P && /* @__PURE__ */ t.createElement(fe, null)
  );
});
W.displayName = "KendoReactSpreadsheet";
W.propTypes = {
  className: l.string,
  defaultProps: l.any,
  toolbar: l.oneOfType([l.bool, l.arrayOf(l.any)]),
  style: l.object,
  onSelect: l.func,
  onChange: l.func,
  onChangeFormat: l.func,
  onExcelImport: l.func,
  onExcelExport: l.func
};
export {
  W as Spreadsheet,
  O as toolsValueMap
};
