/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as i from "react";
import t from "prop-types";
import { validatePackage as A, svgIconPropType as M, classNames as n, uButton as r, UnstyledContext as z, IconWrap as O } from "@progress/kendo-react-common";
import { packageMetadata as w } from "./package-metadata.mjs";
function R({ imageUrl: h, name: e, iconClass: s, svgIcon: c, imageAlt: a, buttonClasses: o }) {
  return h ? /* @__PURE__ */ i.createElement(
    "img",
    {
      role: "presentation",
      className: n(r.icon({ c: o })),
      alt: a,
      src: h
    }
  ) : e || c ? /* @__PURE__ */ i.createElement(O, { className: n(r.icon({ c: o })), name: e, icon: c }) : s ? /* @__PURE__ */ i.createElement("span", { role: "presentation", className: n(r.icon({ c: o }), s) }) : null;
}
const l = class l extends i.Component {
  constructor(e) {
    super(e), this._element = null, this.handleClick = (s) => {
      this.toggleIfApplicable(), this.props.onClick && this.props.onClick.call(void 0, s);
    }, A(w), this.state = { selected: this.props.togglable === !0 && this.props.selected === !0 };
  }
  /**
   * Gets the DOM element of the Button component.
   */
  get element() {
    return this._element;
  }
  /**
   * Returns `true` when the component is togglable and selected ([see example]({% slug toggleable_button %})).
   * Otherwise, returns `false`.
   */
  get selected() {
    return this._selectedTemp !== void 0 ? this._selectedTemp : this.state.selected;
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(e, s) {
    return e.togglable && e.selected !== void 0 && e.selected !== s.selected ? { selected: e.selected } : null;
  }
  /**
   * @hidden
   */
  render() {
    const {
      children: e,
      togglable: s,
      icon: c,
      iconClass: a,
      svgIcon: o,
      imageUrl: u,
      imageAlt: b,
      className: C,
      startIcon: g,
      endIcon: f,
      onClick: S,
      size: k = l.defaultProps.size,
      rounded: E = l.defaultProps.rounded,
      fillMode: P = l.defaultProps.fillMode,
      themeColor: y = l.defaultProps.themeColor,
      ...I
    } = this.props, N = o !== void 0 || c !== void 0 || a !== void 0 || u !== void 0, T = e !== void 0, d = this.context && this.context.uButton, x = R({
      name: c,
      svgIcon: o,
      iconClass: a,
      imageUrl: u,
      imageAlt: b,
      buttonClasses: d
    }), v = (m) => i.cloneElement(m, { className: n(r.icon({ c: d })) });
    return /* @__PURE__ */ i.createElement(
      "button",
      {
        ref: (m) => this._element = m,
        "aria-pressed": s ? this.state.selected : void 0,
        ...I,
        onClick: this.handleClick,
        className: n(
          r.wrapper({
            c: d,
            isRtl: this.props.dir === "rtl",
            selected: this.state.selected,
            disabled: this.props.disabled,
            size: k,
            fillMode: P,
            rounded: E,
            themeColor: y,
            iconButton: !T && N
          }),
          C
        )
      },
      g && v(g),
      x,
      e && /* @__PURE__ */ i.createElement("span", { className: n(r.text({ c: d })) }, e),
      f && v(f)
    );
  }
  toggleIfApplicable() {
    if (this.props.togglable && this.props.selected === void 0) {
      const e = !this.state.selected;
      this._selectedTemp = e, this.setState({ selected: e }, () => this._selectedTemp = void 0);
    }
  }
};
l.propTypes = {
  children: t.node,
  selected: t.bool,
  togglable: t.bool,
  icon: t.string,
  svgIcon: M,
  iconClass: t.string,
  imageUrl: t.string,
  imageAlt: t.string,
  size: t.oneOf([null, "small", "medium", "large"]),
  rounded: t.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: t.oneOf([null, "flat", "link", "outline", "solid", "clear"]),
  // eslint-disable-next-line max-len
  themeColor: t.oneOf([
    null,
    "base",
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "warning",
    "error",
    "dark",
    "light",
    "inverse"
  ])
}, l.defaultProps = {
  togglable: !1,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  themeColor: "base"
};
let p = l;
p.contextType = z;
export {
  p as Button
};
