/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as r from "react";
import t from "prop-types";
import { noop as n, classNames as i, uAnimation as o, UnstyledContext as w } from "@progress/kendo-react-common";
import { CSSTransition as z } from "react-transition-group";
const s = class s extends r.Component {
  constructor() {
    super(...arguments), this.elementRef = r.createRef();
  }
  /**
   * The element that is being animated.
   */
  get element() {
    return this.elementRef.current;
  }
  /**
   * @hidden
   */
  render() {
    const {
      children: g,
      style: y,
      appear: S,
      enter: v,
      exit: b,
      transitionName: a,
      transitionEnterDuration: m,
      transitionExitDuration: c,
      className: R,
      onEnter: E,
      onEntering: d,
      onEntered: x,
      onExit: u,
      onExiting: p,
      onExited: h,
      onAfterExited: f,
      mountOnEnter: A,
      unmountOnExit: N,
      animationEnteringStyle: O,
      animationEnteredStyle: D,
      animationExitingStyle: T,
      animationExitedStyle: j,
      ...q
    } = this.props, e = this.context && this.context.uAnimation, C = i(R, o.childContainer({ c: e })), P = {
      transitionDelay: "0ms",
      ...y
    }, $ = {
      entering: { transitionDuration: `${m}ms`, ...O },
      entered: { ...D },
      exiting: { transitionDuration: `${c}ms`, ...T },
      exited: { ...j }
    }, U = {
      in: this.props.in,
      appear: S,
      enter: v,
      exit: b,
      mountOnEnter: A,
      unmountOnExit: N,
      timeout: {
        enter: m,
        exit: c
      },
      onEnter: () => {
        E && E.call(void 0, { animatedElement: this.element, target: this });
      },
      onEntering: () => {
        d && d.call(void 0, { animatedElement: this.element, target: this });
      },
      onEntered: () => {
        x && x.call(void 0, { animatedElement: this.element, target: this });
      },
      onExit: () => {
        u && u.call(void 0, { animatedElement: this.element, target: this });
      },
      onExiting: () => {
        p && p.call(void 0, { animatedElement: this.element, target: this });
      },
      onExited: () => {
        f && f.call(void 0, { animatedElement: this.element, target: this }), h && h.call(void 0, { animatedElement: this.element, target: this });
      },
      classNames: {
        appear: i(o.appear({ c: e, transitionName: a })),
        appearActive: i(o.appearActive({ c: e, transitionName: a })),
        enter: i(o.enter({ c: e, transitionName: a })),
        enterActive: i(o.enterActive({ c: e, transitionName: a })),
        exit: i(o.exit({ c: e, transitionName: a })),
        exitActive: i(o.exitActive({ c: e, transitionName: a }))
      }
    };
    return /* @__PURE__ */ r.createElement(z, { ...U, ...q, nodeRef: this.elementRef }, (k) => /* @__PURE__ */ r.createElement(
      "div",
      {
        style: {
          ...P,
          ...$[k]
        },
        className: C,
        ref: this.elementRef
      },
      g
    ));
  }
};
s.propTypes = {
  in: t.bool,
  children: t.oneOfType([
    t.arrayOf(t.node),
    t.node
  ]),
  transitionName: t.string.isRequired,
  className: t.string,
  appear: t.bool,
  enter: t.bool,
  exit: t.bool,
  transitionEnterDuration: t.number.isRequired,
  transitionExitDuration: t.number.isRequired,
  mountOnEnter: t.bool,
  unmountOnExit: t.bool,
  animationEnteringStyle: t.object,
  animationEnteredStyle: t.object,
  animationExitingStyle: t.object,
  animationExitedStyle: t.object
}, s.defaultProps = {
  mountOnEnter: !0,
  unmountOnExit: !1,
  onEnter: n,
  onEntering: n,
  onEntered: n,
  onExit: n,
  onExiting: n,
  onExited: n,
  onAfterExited: n,
  animationEnteringStyle: {},
  animationEnteredStyle: {},
  animationExitingStyle: {},
  animationExitedStyle: {}
};
let l = s;
l.contextType = w;
export {
  l as AnimationChild
};
