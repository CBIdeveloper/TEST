/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as n from "react";
import a from "prop-types";
import { StepperContext as oe } from "./context/StepperContext.mjs";
import { validatePackage as se, focusFirstFocusableChild as ne, useDir as re, dispatchEvent as T, Navigation as ie, classNames as F, svgIconPropType as L } from "@progress/kendo-react-common";
import { Step as le } from "./Step.mjs";
import { ProgressBar as ce } from "@progress/kendo-react-progressbars";
import { DEFAULT_ANIMATION_DURATION as ae, NO_ANIMATION as ue } from "./contants.mjs";
import { packageMetadata as de } from "../package-metadata.mjs";
import { useLocalization as fe } from "@progress/kendo-react-intl";
import { progBarAriaLabel as M, messages as me } from "./messages/index.mjs";
const V = n.forwardRef((C, z) => {
  se(de);
  const {
    animationDuration: v,
    children: K,
    className: S,
    disabled: f,
    errorIcon: G,
    errorSVGIcon: H,
    item: N,
    items: m,
    linear: g,
    mode: U,
    orientation: E,
    selectOnFocus: b,
    style: w,
    successIcon: _,
    successSVGIcon: B,
    value: u = 0,
    onChange: I,
    onFocus: h
  } = C, j = fe().toLanguageString(M, me[M]), p = n.useRef(null), D = n.useCallback(
    () => {
      p.current && ne(p.current);
    },
    []
  ), x = n.useCallback(
    () => ({
      element: p.current,
      focus: D
    }),
    [D]
  );
  n.useImperativeHandle(z, x);
  const [q, c] = n.useState(u), d = m ? m.length : 0, o = E === "vertical", y = re(p, C.dir), J = typeof v == "number" ? v : v !== !1 ? ae : ue;
  n.useEffect(() => {
    c(u);
  }, [u]);
  const O = n.useCallback(
    (r, i) => {
      const e = i === u - 1, t = i === u, l = i === u + 1;
      u !== i && I && !f && (!g || e || t || l) && (T(
        I,
        r,
        x(),
        { value: i }
      ), c(i));
    },
    [u, g, I, f, c]
  ), Q = n.useCallback(
    (r) => {
      let i = r.value, e = r.syntheticEvent;
      O(e, i);
    },
    [O]
  ), W = n.useCallback(
    (r) => {
      h && !f && T(
        h,
        r.syntheticEvent,
        x(),
        void 0
      );
    },
    [h, f]
  ), k = n.useMemo(
    () => {
      const r = y === "rtl", i = m.length - 1;
      return new ie({
        root: p,
        selectors: ["ol.k-step-list li.k-step a.k-step-link"],
        tabIndex: 0,
        keyboardEvents: {
          keydown: {
            ArrowLeft: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e);
              !o && !r && s > 0 ? (t.focusPrevious(e), c(s - 1)) : !o && r && s < i && (t.focusNext(e), c(s + 1));
            },
            ArrowRight: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e);
              !o && !r && s < i ? (t.focusNext(e), c(s + 1)) : !o && r && s > 0 && (t.focusPrevious(e), c(s - 1));
            },
            ArrowUp: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e);
              o && !r && s > 0 ? (t.focusPrevious(e), c(s - 1)) : o && r && s > 0 && (t.focusPrevious(e), c(s + 1));
            },
            ArrowDown: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e);
              o && !r && s < i ? (t.focusNext(e), c(s + 1)) : o && r && s < i && (t.focusNext(e), c(s - 1));
            },
            Tab: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e), P = t.previous(e).children[0], A = t.next(e).children[0];
              l.shiftKey ? !o && !r && s > 0 ? (t.focusPrevious(e), c(s - 1), b && P.click()) : !o && r && s < i && (t.focusNext(e), c(s + 1), b && A.click()) : !o && !r && s < i ? (t.focusNext(e), c(s + 1), b && A.click()) : !o && r && s > 0 && (t.focusPrevious(e), c(s - 1), b && P.click());
            },
            Home: (e, t, l) => {
              l.preventDefault(), t.focusElement(t.first, e), c(0);
            },
            End: (e, t, l) => {
              l.preventDefault(), t.focusElement(t.last, e), c(i);
            },
            Space: (e, t, l) => {
              l.preventDefault(), e.children[0].click();
            },
            Enter: (e, t, l) => {
              l.preventDefault(), e.children[0].click();
            }
          }
        }
      });
    },
    [y, m.length, o, c]
  );
  n.useEffect(() => (k.initializeRovingTab(u), () => k.removeFocusListener()), []);
  const X = n.useCallback(k.triggerKeyboardEvent.bind(k), []), Y = n.useMemo(
    () => F(
      "k-stepper",
      {
        "k-stepper-linear": g
      },
      S
    ),
    [g, S]
  ), Z = n.useMemo(
    () => ({
      display: "grid",
      gridTemplateColumns: o ? void 0 : "repeat(" + d * 2 + ", 1fr)",
      gridTemplateRows: o ? "repeat(" + d + ", 1fr)" : void 0,
      ...w
    }),
    [o, d, w]
  ), $ = n.useMemo(
    () => F(
      "k-step-list",
      {
        "k-step-list-horizontal": !o,
        "k-step-list-vertical": o
      }
    ),
    [o]
  ), ee = n.useMemo(
    () => ({
      gridColumnStart: o ? void 0 : 1,
      gridColumnEnd: o ? void 0 : -1,
      gridRowStart: o ? 1 : void 0,
      gridRowEnd: o ? -1 : void 0
    }),
    [o]
  ), te = n.useMemo(
    () => ({
      gridColumnStart: o ? void 0 : 2,
      gridColumnEnd: o ? void 0 : d * 2,
      gridRowStart: o ? 1 : void 0,
      gridRowEnd: o ? d : void 0,
      top: o ? 17 : void 0
    }),
    [o, d]
  ), R = m && m.map((r, i) => {
    const e = {
      index: i,
      disabled: f || r.disabled,
      focused: i === q,
      current: i === u,
      ...r
    }, t = N || le;
    return /* @__PURE__ */ n.createElement(t, { key: i, ...e });
  });
  return /* @__PURE__ */ n.createElement(
    oe.Provider,
    {
      value: {
        animationDuration: v,
        isVertical: o,
        item: N,
        linear: g,
        mode: U,
        numOfSteps: d,
        value: u,
        successIcon: _,
        successSVGIcon: B,
        errorIcon: G,
        errorSVGIcon: H,
        onChange: Q,
        onFocus: W
      }
    },
    /* @__PURE__ */ n.createElement(
      "nav",
      {
        className: Y,
        style: Z,
        dir: y,
        role: "navigation",
        ref: p,
        onKeyDown: X
      },
      /* @__PURE__ */ n.createElement(
        "ol",
        {
          className: $,
          style: ee
        },
        R || K
      ),
      /* @__PURE__ */ n.createElement(
        ce,
        {
          style: te,
          labelPlacement: "start",
          animation: { duration: J },
          ariaLabel: j,
          "aria-hidden": !0,
          max: d - 1,
          labelVisible: !1,
          orientation: E,
          reverse: E === "vertical",
          value: u,
          disabled: f,
          tabIndex: -1
        }
      )
    )
  );
});
V.propTypes = {
  animationDuration: a.oneOfType([a.bool, a.number]),
  children: a.any,
  className: a.string,
  dir: a.string,
  disabled: a.bool,
  errorIcon: a.string,
  errorSVGIcon: L,
  item: a.any,
  items: a.any,
  linear: a.bool,
  mode: a.oneOf(["steps", "labels"]),
  orientation: a.oneOf(["horizontal", "vertical"]),
  style: a.object,
  successIcon: a.string,
  successSVGIcon: L,
  value: a.number.isRequired,
  onChange: a.func,
  onFocus: a.func
};
V.displayName = "KendoStepper";
export {
  V as Stepper
};
