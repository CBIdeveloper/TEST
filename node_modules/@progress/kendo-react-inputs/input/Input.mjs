/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as o from "react";
import i from "prop-types";
import { validatePackage as C, classNames as M, uInput as S, createPropsContext as I, withIdHOC as L, withPropsContext as V, withUnstyledHOC as N } from "@progress/kendo-react-common";
import { FloatingLabel as P } from "@progress/kendo-react-labels";
import { packageMetadata as D } from "../package-metadata.mjs";
const s = class s extends o.Component {
  constructor(e) {
    super(e), this._input = null, this.focus = () => {
      this._input && this._input.focus();
    }, this.isInvalid = (t) => {
      let a = !1;
      for (let l in t)
        t.hasOwnProperty(l) && (a = a || !!t[l]);
      return a;
    }, this.setValidity = () => {
      this._input && this._input.setCustomValidity && (this.validity.valid || !this.validityStyles ? this._input.classList.remove("k-invalid") : this._input.classList.add("k-invalid"), this._input.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || ""
      ));
    }, this.handleChange = (t) => {
      this.setState({
        value: t.target.value
      }), this.valueDuringOnChange = t.target.value, this.props.onChange && this.props.onChange.call(void 0, {
        syntheticEvent: t,
        nativeEvent: t.nativeEvent,
        value: t.target.value,
        target: this
      }), this.valueDuringOnChange = void 0;
    }, this.handleAutoFill = (t) => {
      if (t.animationName === "autoFillStart") {
        let a = t.target.parentNode;
        a && a.classList.contains("k-empty") && a.classList.remove("k-empty");
      }
    }, C(D), this.state = {
      value: this.props.defaultValue || s.defaultProps.defaultValue
    };
  }
  get _inputId() {
    return this.props.id;
  }
  /**
   * Gets the native input element of the Input component.
   */
  get element() {
    return this._input;
  }
  /**
   * Gets the value of the Input.
   */
  get value() {
    return this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value;
  }
  /**
   * Gets the `name` property of the Input.
   */
  get name() {
    return this.props.name;
  }
  /**
   * Represents the validity state into which the Input is set.
   */
  get validity() {
    const e = {
      badInput: this._input ? this._input.validity.badInput : !1,
      patternMismatch: this._input ? this._input.validity.patternMismatch : !1,
      rangeOverflow: this._input ? this._input.validity.rangeOverflow : !1,
      rangeUnderflow: this._input ? this._input.validity.rangeUnderflow : !1,
      stepMismatch: this._input ? this._input.validity.stepMismatch : !1,
      tooLong: this._input ? this._input.validity.tooLong : !1,
      typeMismatch: this._input ? this._input.validity.typeMismatch : !1,
      valueMissing: this._input ? this._input.validity.valueMissing : !1
    };
    return {
      ...e,
      customError: this.props.validationMessage !== void 0,
      valid: this.props.valid !== void 0 ? this.props.valid : this._input ? !this.isInvalid(e) : !0
    };
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : s.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.forceUpdate();
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    this.setValidity();
  }
  /**
   * @hidden
   */
  render() {
    const {
      className: e,
      label: t,
      labelClassName: a,
      id: l,
      validationMessage: F,
      defaultValue: k,
      valid: E,
      unstyled: r,
      // Removed to support direct use in Form Field component
      visited: B,
      touched: U,
      modified: x,
      autoFocus: c,
      ariaLabelledBy: y,
      ariaDescribedBy: g,
      validityStyles: A,
      style: u,
      ariaLabel: m,
      ...n
    } = this.props, h = l || this._inputId, d = !this.validityStyles || this.validity.valid, f = r && r.uInput, b = M(e, S.input(
      {
        c: f,
        invalid: !d,
        disabled: this.props.disabled
      }
    )), v = /* @__PURE__ */ o.createElement(
      "input",
      {
        "aria-labelledby": y,
        "aria-describedby": g,
        "aria-disabled": this.props.disabled || void 0,
        "aria-invalid": !d || void 0,
        "aria-label": m || void 0,
        ...n,
        style: t ? void 0 : u,
        value: this.value,
        id: h,
        autoFocus: c,
        className: b,
        onChange: this.handleChange,
        onAnimationStart: this.handleAutoFill,
        ref: (_) => {
          this._input = _;
        }
      }
    );
    return t ? /* @__PURE__ */ o.createElement(
      P,
      {
        label: t,
        labelClassName: a,
        editorId: h,
        editorValue: String(this.value),
        editorValid: d,
        editorDisabled: n.disabled,
        editorPlaceholder: n.placeholder,
        children: v,
        style: u,
        dir: n.dir,
        unstyled: r
      }
    ) : v;
  }
};
s.displayName = "Input", s.propTypes = {
  label: i.string,
  labelClassName: i.string,
  validationMessage: i.string,
  required: i.bool,
  validate: i.bool,
  id: i.string,
  ariaLabelledBy: i.string,
  ariaDescribedBy: i.string,
  ariaLabel: i.string,
  autoFocus: i.bool
}, s.defaultProps = {
  defaultValue: "",
  required: !1,
  validityStyles: !0,
  autoFocus: !1
};
let p = s;
const O = I(), w = L(V(O, N(p)));
w.displayName = "KendoReactInput";
export {
  w as Input,
  O as InputPropsContext,
  p as InputWithoutContext
};
